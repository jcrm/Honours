cbuffer ScaleBuffer
{
	float3 step_size_;
	float iterations_;
};
cbuffer CameraData
{
	float4 CameraPosition;
	matrix inverse;
};
struct PixelShaderInput
{
	float4 position_ : SV_POSITION;
	float3 tex_		: TEXCOORD0;
};
Texture3D volume_;
SamplerState sample_type_;

float4 RayCastSimplePS(PixelShaderInput input) : SV_TARGET
{ 
	//calculate projective texture coordinates
	//used to project the front and back position textures onto the cube

	float4 CameraPositionTS =  mul(CameraPosition, inverse);
	float4 dst = float4(0.f, 0.f, 0.f, 0.f);
	float4 src = float4(0.f, 0.f, 0.f, 0.f);
	float4 value = 0.f;
	float3 dir = normalize(input.tex_ - CameraPositionTS.xyz);
	float3 pos = input.tex_;
	float3 step = dir /64;
	
	for(int i = 0; i <iterations_; i++){
		value = volume_.SampleLevel(sample_type_, pos,0).r;
		//value = volume_.SampleGrad(sample_type_, pos, 1.f , 1.f ).a;
		src = (float4)value.r;

		src.a *= .5f;
		//reduce the alpha to have a more transparent result
		//this needs to be adjusted based on the step size
		//i.e. the more steps we take, the faster the alpha will grow

		//Front to back blending
		//dst.rgb = dst.rgb + (1 - dst.a) * src.a * src.rgb;
		//dst.a   = dst.a   + (1 - dst.a) * src.a;
		src.rgb *= src.a;
		dst = (1.0f - dst.a)*src + dst;

		//break from the loop when alpha gets high enough
		if(dst.a >= 1.f && value.r == 0){
			break;
		}

		//advance the current position
		pos = pos + step;
	}
	//return float4(input.tex_,0.5);
	return dst;
}