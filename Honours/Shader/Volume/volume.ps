Texture3D volume_;
SamplerState sample_type_;

cbuffer ScaleBuffer
{
	float3 step_size_;
	float iterations_;
};
cbuffer CameraData
{
	float4 CameraPosition;
	matrix inverse;
};
struct PixelShaderInput
{
	float4 position_ : SV_POSITION;
	float3 tex_		: TEXCOORD0;
};

float4 RayCastSimplePS(PixelShaderInput input) : SV_TARGET
{ 
	//calculate projective texture coordinates
	//used to project the front and back position textures onto the cube

	float4 CameraPositionTS =  mul(CameraPosition, inverse);
	float4 dst = float4(0.f, 0.f, 0.f, 0.f);
	float4 src = float4(0.f, 0.f, 0.f, 0.f);
	float4 value = 0.f;
	float3 dir = normalize(input.position_ - CameraPosition.xyz);
	float3 pos = input.position_;
	float3 step = dir * step_size_;

	for(int i = 0; i <iterations_; i++){
		//value = volume_.SampleLevel(sample_type_, pos,0).a;
		value = volume_.SampleGrad(sample_type_, input.tex_, 1.f , 1.f );
		
		src = (float4)value;

		src.a *= .1f;
		//reduce the alpha to have a more transparent result
		//this needs to be adjusted based on the step size
		//i.e. the more steps we take, the faster the alpha will grow

		//Front to back blending
		//dst.rgb = dst.rgb + (1 - dst.a) * src.a * src.rgb;
		//dst.a   = dst.a   + (1 - dst.a) * src.a;
		src.rgb *= src.a;
		dst = (1.0f - dst.a)*src + dst;

		//break from the loop when alpha gets high enough
		if(dst.a >= 1.f){
			break;
		}

		//advance the current position
		pos += step;

	}
	//return float4(dir,1);
	if(dst.a ==0){
	dst.a = 1;
	}
	return float4(dir,1);
}